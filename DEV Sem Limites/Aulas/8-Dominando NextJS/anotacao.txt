Aula 2 - Criando Projeto e Configurando o Shadcn UI
    1-Criei o projeto nextjs 
    npx create-next-app@latest

    2-instalei o shadcn/ui  
    npx shadcn@latest init

    obs: quando instalo o shadcn/ui ele cria a pasta lib com um arquivo chamado utils.ts
    obs2: o shadcn/ui tambem cria o arquivo de configuracao json chamado components.json

    3-instalei todos os componentes do shadcn/ui 
    npx shadcn@latest add avatar badge button calendar card chart checkbox dialog drawer dropdown-menu form input label popover scroll-area select separator sheet sidebar skeleton sonner table tabs textarea tooltip

    obs: Depois de instalar os components do shadcn/ui, ele cria uma pasta chamada components e dentro dela tem todos os componentes instalados.

    4-Logo apos instalar os componentes do shadcn/ui, fui no arquivo src/app/page.tsx e limpei ele deixando apenas um texto e botao do shadcn/ui

Aula 3 - Configurando o Prisma
    link do prisma: https://www.prisma.io/docs/getting-started/quickstart-sqlite

    1-instalei o prisma 
    yarn add prisma

    2-executei o prisma 
    npx prisma init
    obs: O prisma init cria um arquivo chamado prisma/schema.prisma
    eh neste arquivo que sera usado para criar tabelas para o banco de dados.

    3-instalei o docker com ajuda da IA, passando o tutorial que matheus passou:
    Criando Container do Postgres no Docker:

    https://docs.docker.com/engine/install/

    VocÃª pode criar um container Docker com a imagem oficial do PostgreSQL usando o seguinte comando:

    docker run --name meu-postgres \
    -e POSTGRES_USER=postgres \
    -e POSTGRES_PASSWORD=docker \
    -p 5432:5432 \
    -d postgres
    Explicando os parÃ¢metros:
    --name meu-postgres: nome do container.

    -e POSTGRES_USER=postgres: define o usuÃ¡rio do banco.

    -e POSTGRES_PASSWORD=docker: define a senha.

    -p 5432:5432: mapeia a porta local 5432 para a porta 5432 do container.

    -d: executa o container em segundo plano.

    postgres: Ã© a imagem oficial (serÃ¡ baixada automaticamente se vocÃª ainda nÃ£o tiver ela localmente).

    Verificar se o container estÃ¡ rodando:
    docker ps
    Acessar o banco via linha de comando (opcional):
    docker exec -it meu-postgres psql -U postgres

    7-Depois instalei o pg4admin

Aula 4-Implementando PÃ¡ginas de AutenticaÃ§Ã£o
    1-criei as pasta modules, auth, components e schemas. 
    Dentro da pasta components adicionei dois arquivos. O signin-card.tsx e o signup-card.tsx.
    Dentro da pasta schemas adicionei login.ts e register.ts

    obs:
    Dentro dessa pasta modules, se encontram os modulos da aplicacao. 
    Nela, vai ter o modulo de autenticacao, que vai estar na pasta auth.
    Alem do modulo de autenticacao, teremos outros modulos aqui nesta pasta no futuro.

    Dentro da pasta Modules, criei a pasta Auth (que tera tudo referente a autenticacao), dentro dela criei a pasta components e schemas.



    2-Rotas na pasta app
        Para criar a rota de uma pagina, devemos colocar ela dentro da pasta app.
        Neste caso, criei a pasta "(auth)" e dentro dela criei a pasta login e pasta registro com seus arquivos de pagina dentro delas chamados page.tsx. 

        OBS: Lembrando que por conta dos parenteses na pasta "(auth)", ela nao passa a fazer parte da rota, isso serve para somente criar uma organizacao nos arquivos do projeto. Esses parenteses sao chamados de grouping rounting

        OBS:Em resumo, as paginas dentro de App sao redenrizadas pelo nextjs, que por sua vez chamam as paginas de modules para dentro delas.

        Agora, por que eu criei o componente de login e registro loge da pagina?
        Simples, porque sempre criamos as paginas ou rotas na pasta App e o conteudo ou componente em modules. Se eu criar outra pagina em App, ela vai chamar outro componente na pasta modules, seja qual tipo for, auth ou qualquer outro. Em modules vao ser criados todos os componentes divididos em categorias e na pasta App vai ser criado as rotas.


    3-instalacao:
        Para desenvolver os componentes modules/auth/components e modules/auth/schemas, precisamos instalar alguns pacotes.

        intalei:
        yarn add zod @hookform/resolvers react-hook-form

        obs:
        react-hook-form (para fazer todo gerenciamento dos formulÃ¡rios do projeto)
        zod junto com @hookform/resolvers (para fazer a validaÃ§Ã£o dos formulÃ¡rios)
    



    4-Implementando os arquivos de components e schemas do passo 1.
    login.ts e register.ts dentro da pasta schemas.
    signin-card.tsx e signup-card.tsx dentro da pasta components.

        1-Implementei o card de signup-card.tsx.
        obs: o arquivo signup-card.tsx necessita do arquivo de schema, register.ts.
        obs2: no arquivo signup-card.tsx, como usa um hook ele precisa ter 'use client' no topo do arquivo.

        2-Implementei o card de signun-card.tsx
        obs: Identico ao component signup-card.tsx mas retirando a necessidade de nome e modificando algumas coisas e alguns textos.

        3-Criei o layout da aplicacao
            1-Criei o layout.tsx dentro das pasta App, dentro da pasta (auth), para ser a base de toda a aplicacao ou de todas as rotas da aplicacao. Incrivelmente o layout eh lido automaticamente pelo nextjs oq quer dizer que ele precisa ter esse nome para funcionar.
            2-Criei o arquivo logo.tsx dentro da pasta src/components.
            3-Salvei o logo.svg na pasta public/logo.svg
            
            obs: resumindo, o layout.tsx tem o componente logo.tsx dentro dele que por sua vez tem o logo.svg dentro dele.


Aula 05 - Personalizando Componentes do Shadcn/UI
    Fiz a atualizacao dos componentes button.tsx e input.tsx do shadcn/ui. Na pasta src/components/ui.
    E tambem atualizei o signin-card.tsx e signup-card.tsx no tamanho do botao usando size='lg' e coloquei 'e' ente os textos : Politica de Privacidade e Termos de Servico

Aula 06 - Configurando Login Social com AuthJS
    *Segui os passos do tutorial do site do authjs:
    link:https://authjs.dev/getting-started/installation?framework=yarn

        No site 
        passo 1: Installing Auth.js (instalar o authjs)
        Vou no no terminal:
            yarn add next-auth@beta

        No site
        passo 2: Setup Environment (para gerar o arquivo .env.local)
        No terminal:
            npx auth secret

        No projeto:
            1-O arquivo (env.local) que foi criado com o comando acima, pego oq estava escrito nele e passo para (.env) entao excluo o (.env.local).

    *No projeto, ainda no mesmo link:
        link:https://authjs.dev/getting-started/installation?framework=yarn
        Depois fiz como mandava o tutorial Configure ainda no mesmo link do authjs.
        1- Dentro da pasta lib, criei o arquivo auth.ts (colocando dentro dele o codigo que o site do authjs me deu)
        2- Dentro da pasta app, criei as pastas api/auth/[...nextauth] e dentro dela criei o arquivo route.ts (colocando dentro dele o codigo que o site do authjs me deu. Que so foram duas linhas um import e um export)
        3- Dentro da pasta src criei o arquivo middleware.ts. (colocando dentro dele o codigo que o site do authjs me deu)
    
    *Agora com o authjs so preparar o authjs para funcionar com o google. Em outro link do authjs, para fazer o login com o google, fiz assim:
    Acessei o link: https://authjs.dev/getting-started/providers/google 
    Segui o tutorial para adicionar o provider do google:
        Adicionei "AUTH_GOOGLE_ID" e "AUTH_GOOGLE_SECRET" no arquivo (.env)
        e deixei eles em branco  "AUTH_GOOGLE_ID" = "" e "AUTH_GOOGLE_SECRET" = ""

    *No arquivo auth.ts na pasta lib, adicionei o import:
        import Google from "next-auth/providers/google"
        E coloquei o Google na array de providers:
        providers: [Google],

    *Agora precisamos configurar o google para ele gerar dois codigos. Para isso preciso criar no google o taskmaster no link:
        https://console.cloud.google.com/apis/
        clico em "Selecione um projeto" e clico em "Novo projeto"
        Coloquei o nome do projeto "TaskMaster"
        Deixei sem organizacao
        Clico em criar

        1-Depois de criar, vou na aba "api e servicos", depois clico em "credenciais".
        2-Clico em "criar credenciais", depois clico em "ID do cliente OAuth" depois clico em "configurar tela de consentimento do usuario", clico em "Vamos comecar".
        3-Coloco o nome do app "TaskMaster App" e o email do desenvolvedor.
        4-Deixo marcado "Externo"
        5-Coloco meu email
        6-clico em concordo, continuar e criar.

    *Ainda no site do google, VisÃ£o geral de OAuth, clico no botao "Criar um cliente OAuth"
    Preencho os campos
        Tipo de aplicativo: Aplicativo da Web
        Nome do aplicativo: TaskMaster
        URL de origem: http://localhost:3000
        URL de redirecionamento autorizado: http://localhost:3000/api/auth/callback/google
        1-clico em criar
        2-copio o Client ID e o Client Secret, coloco no arquivo .env nos campos "AUTH_GOOGLE_ID" e "AUTH_GOOGLE_SECRET".
        3-La no google eu clico em ok.

    *No arquivo signup-card.tsx, no botao de "criar conta com o google" eu adicionei:
        "onClick={()=>signIn('google')}"
        e importei o signIn:
        import { signIn } from "next-auth/react";
        obs: como neste caso o componente era do lado cliente o metodo signIn vem do next-auth/react.
        Se fosse do lado do servidor, o metodo signIn vem arquivo lib/auth.ts.

    *modifiquei o signup-card.tsx o onClick do botao:
        "onClick={()=>signIn('google', {
            redirectTo: '/',
        })}"

    *No arquivo signin-card.tsx, no botao de "entrar com o google" eu fiz o mesmo que no signup-card.tsx.

    *feito com sucesso!

    *Para testar, na pasta raiz ou home do projeto, page.tsx, coloquei:
        1-async no home 
    Tambem dentro de home:

        2-
        "const session = await auth();
        console.log({session});"

    Importei o auth:
        1-import { auth } from "@/lib/auth";

Aula 07 - Configurando Prisma Adapter
    Necessario fazer a ligacao entre o prisma e o authjs. Pois na situacao em que o usuario faz login e em seguida cria um time na aplicacao, essa informacao eh salva em coockies no navegador mas precisamos que essas informacoes sejam salvas no banco de dados para que essa informacao seja permanente e acessivel em qualquer dispositivo
    Para isso, precisamos criar um adapter.

    1-Acessamos o link do authjs: https://authjs.dev/getting-started/adapters/prisma
    2-executamos os comandos:
        yarn add @prisma/client @auth/prisma-adapter
        yarn add prisma -D

    3-Proximo passo seria colocar a:
        DATABASE_URL=postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA
        Mas ja temos ela no arquivo .env ja configurada:
        DATABASE_URL="postgresql://postgres:docker@localhost:5432/taskmaster?schema=public"

    4-Criar o arquivo prisma.ts na pasta lib.
        O arquivo prisma.ts deve ter o codigo sujerido pelo tutorial do site do authjs.
    obs: esse arquivo prisma.ts serve para fazer a ligacao entre o prisma e o authjs. Deixando o prima globalmente acessivel para a aplicacao. Pois sem ele pode ocorrer erros de excessao pois estariamos fazendo muitiplas conexoes para o banco de dados.

    5-Modificando o auth.ts dentro da pasta lib:
        import { PrismaAdapter } from "@auth/prisma-adapter";
        import { prisma } from "./prisma"

        Adicionamos tambem
        adapter: PrismaAdapter(prisma)


    6-Criamos o schema do PostgresSQL
        Dentro da pasta raiz do projeto, prisma acessando o arquivo schema.prisma. Subistituimos o codigo que havia la pelo o schema completo sujerido pelo tutorial do authjs.
    obs: o schema.prisma vai conter todas as informacoes necessarias que os providers vao permetir que a gente tenha acesso. Vamos ter acesso ao access token, tempo de expiracao, nome de usuario, imagem de perfil, email, etc.

    7-Precisamos instalar o migrate para atualizar o banco de dados toda vez que foi necessario.
        Para isso vamos executar no terminal:    
        yarn prisma migrate dev

        obs: ou seja, como nesta vez que eu modifiquei o banco de dados, adicionando varias tabelas como a tabela, users, account, sessions e etc eu devmo executar o comando yarn prisma migrate dev para subir essa modificacao no banco de dados, parecido com i github.

        Agora, toda vez que o usuario for autenticado, os dados do usuario serao salvos no banco de dados e nao nos coockies como era antes.

        obs: fiz login e notei que no terminal do VSCODE tinha os campos createdAT e updatedAT o que quer dizer que o banco de dados foi atualizado.
    
Aula 08 - Verificando PÃ¡ginas Autenticadas
    1-No arquivo src/app/page.tsx
        Adicionei a linha de codigo:
        if(!session || !session.user) {
            redirect("/login");
          }

        obs: para verificar se o usuario esta logado ou nao. Se nao estiver logado, redireciona para a pagina de login.
    2-No arquivo src/app/(auth)/login/page.tsx
          Adicionei a linha de codigo:

          if(session) {
            redirect("/");
          }
        obs: para verificar se o usuario esta logado ou nao. Se estiver logado, redireciona para a pagina de home.
    3-No arquivo src/app/(auth)/registro/page.tsx
        Adicionei a linha de codigo:
        if(session) {
            redirect("/");
          }
          obs: para verificar se o usuario esta logado ou nao. Se estiver logado, redireciona para a pagina de home.

Aula 09 - Configurando HonoJS
    Do mesmo jeito que criamos rotas na pasta App do site no nextjs, tambem podemos criar rotas para o lado servidor no nextjs, criar rotas para o lado servidor se chama router handlers. por exemplo se criar uma rota app/api/users/[userID]/route.ts, essa rota sera acessada pela url http://localhost:3000/api/users/1 se por acaso dentro do route.ts tivermos escrito userid em vez de userID, nao sera exibido nada ou seja nao eh type safe. Alem disso para definir a rota para o lado servidor/beckend eh feita por pasta igual a rota do cliente.

    A necessidade de criar as rotas no backend nÃ£o servem exatamente pra "agrupar" dados, mas sim pra fornecer, processar ou receber dados.
    ðŸ”„ GET â†’ pegar dados (ex: /api/jogos retorna lista de jogos)

    ðŸ“¤ POST â†’ enviar dados (ex: /api/contato salva mensagem)

    ðŸ”’ AutenticaÃ§Ã£o â†’ validar login, cookies, tokens, etc.

    âš™ï¸ LÃ³gica server-side â†’ formatar, filtrar, conectar com banco ou API externa

    Ou seja, elas sÃ£o pontos de entrada pro frontend conversar com o backend. Agrupar dados pode ser uma consequÃªncia, mas nÃ£o o foco principal.

    Explicacao 2:

    ðŸ‘‰ **Frontend (navegador)** â†’ **manda requisiÃ§Ã£o** (fetch, axios, etc.) â†’ **para o backend (rotas API)**  
    ðŸ‘‰ Essas rotas **rodam no servidor**, entÃ£o **Ã© o backend que fala direto com o servidor** (banco de dados, serviÃ§os externos, etc.)

    Resumindo:

    - Frontend **nunca acessa o servidor direto**
    - Sempre passa **pelas rotas backend** (que ficam no servidor)
    - Essas rotas Ã© que fazem o trabalho pesado (buscar, salvar, validar, etc.)

    Ã‰ tipo um **intermediÃ¡rio de confianÃ§a** entre o navegador e o servidor real.

    1-Acessando o site
    link: https://hono.dev/docs/getting-started/vercel

    2-Executando o comando:
    yarn add hono

    3-Criando o arquivo
        1- na pasta src/app/api criamos a pasta [[...route]] e seu arquivo route.ts
        2- na pasta src/modules criamos a pasta teams e seu arquivo route.ts
        3- dentro do route.ts da pasta api adicionamos todas as rotas api/backend do site.
    
    4- Configurando RPC
    RPC (Remote Procedure Call) com tipagem compartilhada.
    No nosso backend, vamos retornar uma lista de times direto do banco de dados para ser mostrado ao front, por exemplo. E com esse recurso RPC garantimos que os tipos retornados pelo backend seja do mesmo tipo que a gente vai acessar no frontend.

        1-no arquivo route.ts da pasta [[...route]] criamos a variavel const routes que recebe todas as rotas api, ficou assim:
        const routes = app.route("/teams", teams);
        
        2-Ainda no arquivo route.ts da pasta [[...route]]. Depois adicionamos uma linha de codigo:
        export type AppType = typeof routes;
        obs: o AppType vai saber os tipos de todos os dados que estao sendo retornados pelo backend.

        3-Na pasta src/lib criamos o arquivo rpc.ts com seu codigo

        4-No arquivo .env adicionamos a variavel de ambiente:
        NEXT_PUBLIC_API_URL=http://localhost:3000

Aula 10 - Adicionando Session Middleware
    1-Na pasta src/modules/auth  criamos o arquivo sessionMidleware.ts
        obs: E para que serve ele? Quando fizer uma requisicao para o backend, determinados endpoints sao protegidos e nao podem ser acessados por qualquer usuario. Para isso, criamos o arquivo sessionMiddleware.ts para verificar se o usuario esta logado ou nao. Resumindo, ele faz com que o usuario so tenha acesso a certos endpoints se o usuario estiver autenticado.
    2- Antes de implementar o sessionMiddleware.ts, precisamos executar o comando:
    yarn add server-only
    obs: para bloquear o uso de qualquer codigo no client

    3-no topo do sessionMiddleware.ts adicionamos:
    import 'server-only';
    obs: agora o nosso arquivo sessionMiddleware.ts so pode ser executado no lado servidor.

    4- implementando
        Foi implementado o basico de autenticacao, para ter acesso ao dados. Verifica se o usuario esta logado, caso nao, mostra a mensagem unauthorized. Caso sim, o usuario passa a ter acesso aos dados do banco de dados.
Aula 11 - Implementando PÃ¡gina de CriaÃ§Ã£o de Times
    Antes de implementar a pagina de times iremos instalar a biblioteca (TanStack Query) que antigamente era chamada (React Query).
    link:https://tanstack.com/query/latest/docs/framework/react/installation
    1-Instalando o TanStack Query
    yarn add @tanstack/react-query
    
    2-Indo na barra de pesquisa no site do TanStack Query, pesquisamos por "advance" e selecionamos a opcao "Advanced Server Rendering" ou acessamos o link: https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr#advanced-server-rendering
          obs: eh uma customizacao a mais que precisamos fazer no  tanstack quando usamos o nextjs.
    3-Na parte escrito "Initial Setup" copiamos o codigo.
    4-No projeto, vamos na pasta src/components e criamos o arquivo "query-provider.tsx", e colamos o codigo copiado nele.
    5-Modifiquei o "query-provider.tsx" retirando o default da ultima funcao e troquei o nome da ultima funcao para QueryProvider
    6-Na pasta src/app no arquivo layout.tsx adicionamos a tag do QueryProvider envolvendo o children.
    obs: faz com que o react query fique acessivel para todos os componentes da aplicacao.

    7-Na pasta App, criamos um novo agrupamento de rotas chamado "(no-sidebar)"
    obs: o no-sidebar quer dizer que toda pagina que estiver dentro dele nao tera barra de navegacao em seu layout, so tera o logo do projeto no topo.
    8-Criamos dentro de (no-sidebar) o arquivo "layout.tsx" que sera quase igual ao arquivo layout.tsx da pasta src/app/(auth), com a diferenca no nome "NoSideBarLayout" e "NoSideBarLayoutProps" no lugar de "AuthLayout" e "AuthLayoutProps" e adicionamos a tag link envolvendo o logo.
    9-Na pasta src/app/(no-sidebar) criamos as pastas time/criar e dentro da pasta "criar", criamos o arquivo "page.tsx" com alguns codigos basicos e adicionamos uma tag CreateTeamForm que ainda nao foi implementada.
    10-Na pasta src/modules/teams criamos a pasta "components" e dentro dessa nova pasta criamos o arquivo "create-team-form.tsx" que sera a implementacao do CreateTeamForm.
    11- Na pasta src/modules/teams criamos a pasta "schemas" e seu arquivo create-team.ts que sera o schema do create-team-form.tsx para a tipagem.
    12-Prosseguimos com a implementacao do create-team-form.tsx.

Aula 12 - API de CriaÃ§Ã£o de Times
    1-Vamos criar schemas no prisma
        No a pasta prisma vamos no arquivo schema.prisma

    2-Depois de adicionar os schemas e modificar o schema user, vou no terminal e executo o comando para executar a migration:
    yarn prisma migrate dev

    3-Vamos para a pasta, src/modules/teams/ route.ts e adicionamos a rota "post" para criar times.
        1- Mas antes de terminar de criar, vamos fazer uma verificacao para o lado do servidor. No front-end garantimos com zod que os dados estao no formato que o servidor espera no arquivo "create-steam.ts" na pata src/modules/teams/schemas, mas no lado do servidor, precisamos fazer a mesma verificacao para quando der erro, precisamos saber o que aconteceu, com o zod integrado com hono.
        
        2-Para isso vamos instalar a biblioteca:
        yarn add @hono/zod-validator

        3-Continuamos a implementacao da rota post.

        4-Vamos na pasta src/app/api/[[...route]]/route.ts e adicionamos a rota post.
        "export const POST = handle(app)"
        5-Precisamos fazer um hook com react query para interagir com o route.ts da pasta modules/teams/route.ts.
        
        Dentro da pasta modules/teams criamos a pasta "hooks" e dentro dela o arquivo "use-create-team.ts" que vai ser nosso hook.

        6-Voltamos para a pasta src/module/teams/components/create-team-form.tsx e adicionamos o hook useCreateTeam.
            1-Criamos o onSubmit para enviar os dados para o servidor.
            2-e criamos handleFileChange para mudar a imagem do time.
        7- por fim, na parte do componente, do arquivo create-team-form.tsx, adicionamos ao input as propriedades:
            onChange={handleFileChange}
            disabled={isPending}
            
            e adicionamos disabled={isPending} tambem no button. Para que quando o usuario estiver enviando os dados para o servidor, o formulario fique desabilitado.  Para nao ser possivel enviar mais de uma vez os dados.

Para exclarecimento o fluxo eh o seguinte:
1-o componente create-team-form.tsx usa o hook use-create-team.ts.
Esse hook usa a funcao Post para enviar os dados para o servidor.
O hook tem acesso ao posto gracas ao arquivo da pasta app/api/[[...route]]/route.ts que exporta a rota post.
E a rota post ou funcao post eh criada na pasta modules/teams/route.ts.


13 - Redirecionando para CriaÃ§Ã£o de Times
    Essa eh a validacao para quando o usuario logar, se caso nao tiver nenhum time ele ira diretamente para a pagina de criacao de times e se caso ele ja tiver um ou mais times, quando logar, ele ira para a pagina do primeiro time criado ou do unico time que ele tiver (ira para a pagina do time retornado.)
    1- na pasta src/module/teams no arquivo queries.ts criamos a funcao getTeams que redireciona o usuario para o primeiro time que ele participa se caso nao participar de nenhum time, ele ira para a pagina de criacao de times.

    2- na pasta src/app/ no arquivo page.tsx e implementamos a funcao getTeams para redirecionar. 
    obs: o interessante que essa pagina deixa de ser usada para exibir os algo para ser usada somente para redirecionar o usuario pois deletamos o return.

Aula 14 - Upload de Imagens no AWS s3
    1-seput do codigo. Primeiro acessamos o link:
    https://vercel.com/templates/next.js/aws-s3-image-upload-nextjs

    2-Clicamos em "view demo" e vamos ate esse caminho:
    Depois no caminho: 
    https://github.com/vercel/examples/blob/main/solutions/aws-s3-image-upload/app/api/upload/route.ts
    Copiamos quase todo o codigo.

    3- No projeto, na pasta src/modules criamos a pasta files e dentro dela o arquivo "route.ts" faco ate o async, deixando o async vazio.

    4- Vou para a pasta src/app/api/[[...route]]/route.ts e adicionamos a linha:
    .route('/files', files)
    5- Na pasta src/modules criamos a pasta schemas e dentro dela o arquivo "file-upload.ts" que sera o schema para o upload de imagens.
    6- Voltamos a pata src/modules/files/route.ts e adicionamos dentro do async o codigo que copiamos do github(no passo 2).
    7- Modificamos o codigo.Para fazer essas modificacoes/adaptacoes precisamos instalar as libs:
    yarn add @aws-sdk/client-s3 @aws-sdk/s3-presigned-post @aws-sdk/signature-v4-crt aws-crt aws-sdk uuid
    8-Depois instalamos os tipos do uuid:
    yarn add @types/uuid -D
    9- Depois de modificar o codigo do src/modules/files/route.ts. Vamos para o arquivo src/modules/teams/components/create-team-form.tsx e adicionamos o codigo para o upload de imagem dentro de onSubmit:

    if(data.image instanceof File) {
        const { url, fields } = await presignFile({
            json :{
                contentType: data.image.type,
            }
        })
    }
    10- Vamos no link:
    https://github.com/vercel/examples/blob/main/solutions/aws-s3-image-upload/app/page.tsx

    e copiamos o codigo dele:
        const formData = new FormData()
        Object.entries(fields).forEach(([key, value]) => {
        formData.append(key, value as string)
        })
        formData.append('file', file)

        const uploadResponse = await fetch(url, {
        method: 'POST',
        body: formData,
        })

        Colamos esse codigo copiado dentro do if que fizemos no passo 9, mas modificamos uma linha:
        de 
        formData.append('file', file)
        para
        formData.append('file', data.image)

    11- Seguindo o tutorial do link:
    https://vercel.com/templates/next.js/aws-s3-image-upload-nextjs
        1-Criamos um backet no s3 no link:
        https://console.aws.amazon.com/s3/
            -clicamos em "criar bucket"
            -colocamos o nome do bucket de "teskmaster-files-aula"
            -deixamos selecionado "ACLs enabled" e "Bucket owner prefered"
            -desmarcamos a opcao "Block all public access"
            -marcamos a opcao "i acknowledge that the current settings might result in this bucket and the objects within becoming public"
            -apertamo em "criar bucket"

        2-criamos um usuario no IAM no link:
        https://aws.amazon.com/iam/
            -clicamos no unico botao da tela 
            -No menu da esquerda, clicamos em "usuarios" e depois "criar usuario".
            -Coloco o nome do usuario
            -aperto "next", depois em "next" e por ultimo em "criar usuario"

            2.1-Criando a politica
            -No mesmo lugar assim que criamos o usuario IAM, vamos no menu da esquerda e clicamos em "politicas" e depois "criar politica". 
            -Na aba servicos, elecionamos s3. 
            -Na aba Acoes permetidas selecionamos as opcoes: 
                s3:DeleteObject, s3:GetObject, s3:ListBucket, s3:PutObject, s3:PutObjectAcl
            -Depois, na aba recursos, clicamos em "Tudo"
            -Aperto em "proximo"
            -Coloco o nome da minha politica:
             "user-test-policies"
            -Aperto em "criar politica"
        3-Vamos na pagina do usuario IAM:
        https://us-east-1.console.aws.amazon.com/iam/home?region=us-east-1#/home

            -clicamos em usuarios
            -selecionamos o user-aula
            -clicamos em "adicionar permissoes"
            -clicamos novamente em "adicionar permissoes"
            -clicamos em "anexar politicas diretamente"
            -Pesquisamos por "user-test-policies" e selecionamos ela
            -Aperto em "next"
            -Aperto em "adicionar permissoes"
            Aparece um aviso de politica adicionada em verde no topo da tela.
        4-Voltamos a pagina do usuario IAM:
        https://us-east-1.console.aws.amazon.com/iam/home?region=us-east-1#/home
            -clicamos em usuarios
            -selecionamos o user-aula
            -clicamos em "credencias de seguranca"
            Na aba "Chaves de acesso", clicamos em "criar chave de acesso"
            -Selecionamos a opcao "Aplicacao executada fora do AWS"
            -Clico em next
            -Clico em "criar chave de acesso"
            Aparece um aviso dizendo que a chave de acesso foi criada em verde no topo da tela.
    12-Voltamos aos arquivos do github:
    https://github.com/vercel/examples/blob/main/solutions/aws-s3-image-upload/.env.example
        1-Vamos no projeto, no arquivo .env e colamos as linhas:
            AWS_ACCESS_KEY_ID=
            AWS_SECRET_ACCESS_KEY=
            AWS_REGION=
            AWS_BUCKET_NAME=

        e adiciono as chaves que acabei de criar no passo 11.4 e pegamos o mesmo dome do bucket criado no passo 11.1. E colocamos a regiao do bucket "sa-east-1"
        2-Vamos no arquivo src/modules/files/route.ts e modificamos a             
            AWS_ACCESS_KEY_ID= ""
            AWS_SECRET_ACCESS_KEY= ""
            AWS_REGION= "sa-east-1"
            AWS_BUCKET_NAME= "teskmaster-files-aula"
        3- Volto no link do tutorial:
        https://vercel.com/templates/next.js/aws-s3-image-upload-nextjs
        
        Vou no meu bucket na aba de "permissoes":
        https://sa-east-1.console.aws.amazon.com/s3/buckets/teskmaster-files-aula?region=sa-east-1&bucketType=general&tab=permissions 
        
        vou ate o fim em CORS e mando editar, coloco o codigo abaixo e salvo:
        [
            {
                "AllowedHeaders": [
                    "*"
                ],
                "AllowedMethods": [
                    "GET",
                    "PUT",
                    "POST",
                    "DELETE"
                ],
                "AllowedOrigins": [
                    "*"
                ],
                "ExposeHeaders": []
            }
           ]

           obs: esse codigo foi copiado do tutorial:
           https://vercel.com/templates/next.js/aws-s3-image-upload-nextjs

        obs: Pronto, agora se eu executar a aplicacao, yarn dev e ir em localhost:3000/time/criar, e selecionar a imagem e digitar nome do time e mandar criar, vai ser redirecionado para uma pagina com erro 404.
        Se formos para o bucket, vemos que a imagem foi enviada.
        https://sa-east-1.console.aws.amazon.com/s3/buckets/teskmaster-files-aula?region=sa-east-1&bucketType=general&tab=objects

        5- Agora precisamos pegar a imagem e salvar no banco de dados.
            -No projeto, em src/modules/teams/components/create-team-form.tsx( no front-end) adicionamos os codigos para pegar a imagem.
            adicionamos as linhas:

                *let image: string | undefined = undefined
                *image = `${url}/${fields.key}`
                dentro de 
                "mutate({
                    json: {
                        name: data.name,
                        image: ""
                    }
                }"
            So apaguei os dois pontos e aspas duplas.

            -No projeto, em src/modules/teams/route.ts (no beckend) 
                Na linha:
                    "const { name, image } = c.req.valid('json')"
                    obs:Adicionei image
                Na linha:
                "const team = await prisma.team.create({
                    data: {
                    name,
                    userId: user.id as string,
                    inviteCode: 'abc123',
                    image: image as  string,
                    },
                })"
                obs: adicionei: "image: image as  string,"
            Pronto, dicionamos o codigo para salvar a imagem no banco de dados. Se testar de novo criando um novo time e olhar no. PGAdmin 4, na tabela "Team" podemos ver o time criado e o link da imagem do time salva.
            Alem disso, no https://sa-east-1.console.aws.amazon.com/s3/buckets/teskmaster-files-aula?region=sa-east-1&tab=objects&bucketType=general, podemos ver que a imagem esta la tambem.



