DevBooks
1-Overview do Projeto
OBS: Vimos como sera o projeto

2-Iniciando DevBooks
OBS: usamos o comando "yarn create vite projeto-02-devbooks --template react-ts" para criar o projeto. 
Em seguida usamos o comando "yarn" para instalar dependencias
Em seguida usamos o comando "yarn dev" para abrir o projeto no navegador

3-Configurando ESLint e Prettier
OBS:criei os arquivos .eslintrc.json e .prettierrc com as configuracoes do link e adicionei ao arquivo settings.json do VScode as configuracoes do link. (para abrir o settings.json devemos abrir usando ctrl + shift + p = preferencias: abrir as configuracoes do usuario)

https://gist.github.com/gcmatheusj/54c966371a4485c8318ab75a618d6dc2

4-Configurando Axios
OBS: usamos a API https://www.googleapis.com/books/v1/volumes?q=search+terms do site do google: https://developers.google.com/books/docs/v1/using?hl=pt-br#PerformingSearch mas para isso instalamos antes o AXIOS, no terminal: yarn add axios

deletamos alguns arquivos bases da criacao do react do vite como app.css e main.css alem de limpar o codigo do app.tsx

deletamos a pasta assets

criamos a pasta services e dentro dela criamos o arquivo responsavel por fazer a requisicao no google books utilizando o AXIOS

5-Configurando Styled Components
OBS: adicionamos a biblioteca styled components no terminal do projeto : yarn add styled-components

em seguida instalando as definicoes de tipos no terminal:
yarn add @types/styled-components -D

criamos os estilos globais: criamos uma pasta styles e dentro dela o arquivo global.ts

6-Configurando React Router Dom (Páginas)
OBS: criei a pasta pages e dentros delas as pages search, books e bookdetail 
logo depois instalei usando o terminal: yarn add react-router-dom para fazer a navegacao entre essas paginas

7-Criando SearchBox
OBS: criei a pasta components e criei a searchbox. 

Logo apos isso criei a pasta icons e criei o svg da lupa para colocar no searchbox.

Para utilizar esse svg, instalamos no projeto usando o terminal um plugin para svg no vite: 
yarn add vite-plugin-svgr

Depois adicionamos a configuracao no arquivo vite.config.ts o import do svgr e logo abaixo adicionei 
svgr()

Por ultimo no arquivo tsconfig.json, bem no final adicionei: "types": ["vite-plugin-svgr/client"]

8-Criando Página de Busca
OBS: fiz a estilizacao da primeira pagina, dentro da pasta Search no arquivo Search.styles.ts

9-Entendendo o hook useEffect
OBS:

/* useEffect(()=>{
        // imprimi a palavra Efeito a cada 1 segundo
        const interval = setInterval(()=> { 
            console.log('Efeito')
        }, 1000)

        //se caso mudarmos de pagina o use effect para gracas a esse return
        return () => {
            clearInterval(interval)
        }

    },[])//com a chaves "[]" (array de dependencia) vazia, podemos fazer com que o useEffect so execute uma vez e bem na hora que a pagina abrir. */
    obs: se eu colocar algo dentro da array de dependencias, se esse algo sofrer alteracao ele ira executar o useEffect, como se fosse realmente um efeito colateral.




10-Criando Página de Resultado da Busca de Livros
OBS: uso a api para buscar os livros, crio um hook useEffect para fazer essa busca assim que a pagina abrir usando oq foi digitado que foi passado como parametro na barra de pesquisa. 
Com livros em "maos" armazeno em um estado useState e faco duas interfaces

11-Criando Thumbnail dos Livros
OBS: Criei a pasta Thumbnail e criei o componente Thumbnail, que sera usado na pagina books.tsx ou seja, na pagina do resultado dos livros

12-Estilizando Página de Resultados
OBS: estilizei a pagina dos livros com o arquivo books.styles.ts. O titulo, subtitulo, li e ul 

13-Criando Página de Detalhes do Livro
OBS:criei a rota e a pagina com sua e estilziacao entretanto na descricao do livro, vem com html e para retirar tag html nessa descricao no texto da descricao do livro, instalei :
yarn add react-html-parser e yarn add @types/react-html-parser -D. Logo apois isso adicionei o import: import ReactHTMLParser from 'react-html-parser'. Essa biblioteca se chama: React Html Parser.

Por ultimo, criamos um botao de retorno

14-Adicionando Spinner (Loading)
OBS:Criei o componente spinner e coloquei ele na pagina Books.tsx e BookDetail.tsx

15-Tornando o DevBooks Responsivo
OBS:fiz o site ficar responsivo

Parte 2 do projeto devbooks-------------------------------------------------------

1-Criando Tema da Aplicação
OBS:Criei o arquivo theme.ts com varios estilos css e em seguida criei o arquivo styled-components.d.ts para fazer a interface do arquivo theme.ts para entao o vscode entender o tipo de dado do theme. Para ter acesso as informacoes dele.

2-Atualizando Estilos Globais
OBS: Normalizei o global.ts dos estilos globais usando o theme

3-Criando Button
OBS:Deletei as pages e os componentes e em seguida criei uma nova page inicial, a page SignIn. Logo apos eu criei o estilo do componente botao. Vale lembrar que o botao nao foi criado pois reaproveitamos o botao do proprio react, apenas criamos o button.styles.ts do botao.

4-Criando Input
OBS: Adicionei a cor do texto global no global.ts usando o theme. fiz o componente input por completo, index.ts, input.styles.ts, input.tsx. E por ultimo coloquei o componente input criado na pagina SignIn.tsx 

5-Criando Link
OBS:Criei o componente link, mas nao criei exatamente o componente pois vamos usar o componente link do react router doom. No fim adicionei na pagina SignIn

6-Criando Logo DevBooks
OBS:criei a logo utilizando o vite svgr

7-Página de Login
OBS:Criei a estilizacao da pagina de login criando o arquivo Auth.styles.ts, mas esse arquivo fica apenas dentro da pasta Auth pois esse mesmo arquivo de estilo servira tambem para a pagina de SignOut 

8-Página de Cadastro
OBS:Criei a interface de cadastro (SignUp) com a mesma estrutura do SignIn para manter o padrao de design do site. Adicionei a rota no App.tsx e a rota do botao "cadastre-se" no SignIn.tsx

9-Controlled vs Uncontrolled (estudo)
OBS:Componentes controlados e componente nao controlado. Componente controlado e o componente que armazena estado, por exemplo em um imput. Resumindo o componente pai armazena com um useState para ser usado em um componente input dentro do retorno do codigo. A desvantagem eh que cada vez que o usuario digita um caractere no input o componente eh reenderizado, fazendo assim mais processamento. A vantagem eh a flexibilidade no uso dos dados digitados no input.


Ja no nao controlado, nao existe o uso do useState. O que acontece eh que o componente input acessa diretamente os dados digitados. A desvantagem eh que nao se tem uma flexibilidade no uso recolhido dos dados. A vantagem eh que o componente somente eh redenrizado apenas uma vez. No projeto DEVbooks eh usado o nao controlado no input na pagina de login e cadastro.

10- Gerenciando Formulários com React Hook Form
Instalei o react hoock form, no terminal: yarn add react-hook-form
Alterei o input adicionando o forwardRef por fora do componente Input para que ele consiga receber a ref.
Ja no signIn.tsx eu coloquei o register em cada input.

Alem de pegar o register de dentro do useForm, pegamos o handleSubmit tambem (essas funcoes ja vem com o useForm). 
Criei a funcao onSubmit, para usar no handleSubmit. A funcao handleSubmit faz com que os dados sejam enviados para algum lugar, e o onSubmit que criei faz a execucao dos dados digitados no input junto com handleSubmit

obs: Lembrando que o register eh para pegar oq foi digitado no input (exclusivo para componente nao controlado, como neste caso). register atua exatamente como ref (Ref no react eh um meio de acessar diretamente no html da pagina. Acessa oque foi digitado no input no html. Entao o register adiciona ref ao componente input.)

resumindo: Fizemos as alteracoes no componente input.tsx, index.ts(index do input), signIn.tsx e singUp.tsx



11-Validando Formulários com Zod
OBS: Para validar os dados no input email e senha, vamos instalar o zod e hookform/resolvers(uma biblioteca para integrar o react hookform ao zod). No terminal: yarn add zod @hookform/resolvers. Lembrando que anteriormente eu instalei o react hookform. 
Em seguida importei o zodresolver e o z, criei o validationSchema (esquema de validacao) e subistitui a interface pelo z.infer typeof. 
Fiz a integracao do zod com react hookform. com o formState: {errors} peguei a mensagem de erro e coloquei ela no em cada input nas paginas SignIn e SignUp.

12-Introdução a Context API
OBS:Revisei o problema de prop drilling, que seria a passagem de props em 3 ou mais componentes. para resolver isso existe o context api que seria o uso do hook useContext. Com o context api um estado pode ficar acessivel a todos os componentes independente da onde eles estiverem.
    Primeiro para criar o contexto, precisamos fazer duas coisas, criar o createContext({} as user) com valor fazio nas chaves e Segundo, criar o provider para criar e tornar um estado global. (ISSO FIZ DENTRO DO AuthContext.tsx)

13-Criando Contexto de Autenticação
OBS:assim como no passo 12, criamos um contexto de autenticacao para a aplicacao(site). Criei a pasta context e seus arquivos AuthContext, criei a pasta constants e seu arquivo storage e adicionei a tag AuthProvider no app.tsx (para que os componentes tenham acesso ao contexto)

Dentro do AuthContext.tsx, temos o context e o AuthProvider. no retorno do AuthProvider, no value temos que colocar tudo que for compartilhado globalmente entre os componentes.



14-Hook useAuth
OBS: Sabemos que para usar o contexto (o que foi gravado como globalmente, seja funcoes e variaveis) temos que usar o hook useContext mas nesse caso criei um hook (useAuth) para subistituir ele, para tratar o erro para caso nao conseguir pegar o contexto.

Criei um custom hook chamado useAuth.ts dentro da pasta hooks, que acessa todos os dados do contexto criado no passo 13 (ou seja o: sessions, signIn, signUp, signOut, isAuthenticated, user). E para realmente ter acesso ao dados do contexto, inseri o hook criado (useAuth) na pagina de signIn.tsx e signUp.tsx. Isto para que a pagina signIn possa acessar.

Dentro do signIn.tsx eu inseri: const { signIn } =useAuth() 
e logo depois dentro da funcao onSubmit inseri: await signIn(data)

Fiz a mesma coisa na pagina de signUp (pagina de cadastro)

15-setup devbooks api
OBS: instalei os programas e banco de dados seguindo esse tutorial https://github.com/joaopedrott/devbooks-api

16-Configurando React Query
OBS: React Query eh um gerenciador de estado assincrono. Ele serve para auxiliar para quando a gente trabalha com dados que vem de servidor ( de uma api(backend)) a gente consegue criar cache dos dados que vem do servidor entre outras coisas.

Primeiro instalei no terminal do projeto:
yarn add @tanstack/react-query

depois
yarn add @tanstack/eslint-plugin-query -D

adicionei no arquivo .eslintrc.json:
"plugins": ["react", "react-hooks", "@typescript-eslint", "@tanstack/query"],

no arquivo app.tsx eu coloquei:
const queryClient = new QueryClient

e adicionei a tag QueryClientProvider para envolver toda a aplicacao
<QueryClientProvider client={queryClient}> </QueryClientProvider>

    Com isso, configurei o react query de forma global.
    Lembrando. Dentro de client={queryClient} teremos o cache salvo nele

    Em todos os lugares que precisar usar os hooks do react query, irei ter todos os dados de cache nesse componente <QueryClientProvider>

    O cache eh importante pois diminui a quantidade de requisicoes pois se caso for feita uma mesma requisicao mais de 1 vez ele usara o cache da ultima requisicao para assim nao precisar fazer requisicao a API do backend

17-Hook useSignInMutation
OBS: Para fazer requisicao, fiz o hook useSignIn. 
Primeiro, criei o arquivo .env na raiz do projeto.
Segundo, criei o arquivo api  na pasta services e exclui o arquivo googleBooksApi.js
Terceiro, criei o arquivo useSignIn.ts (esse eh o hook para fazer requisicoes de login)
Quarto, adicionei ao AuthContext.tsx a linha: const signInMutation = useSignIn()
logo apos isso adicionei dentro da funcao signIn no arquivo do AuthContext.tsx:         

await signInMutation.mutateAsync(user,{
            onSuccess: (session) => {
                setSession(session)
                localStorage.setItem(DEV_BOOKS_SESSION_KEY, JSON.stringify(session))
            }
        })

resumindo, a pagina de login SignIn.tsx tem acesso a funcao de login global compartilhada pelo context api. Quando o botao do formulario da pagina for apertado ele envia os dados de login para essa funcao de login da context api no arquivo AuthContext.tsx, essa funcao de signIn chama a funcao useSignIn dentro do arquivo useSignIn.ts passando como props os dados de login ainda no arquivo useSignIn.ts ela chama a funcao asincrona signInUser .


18-Hook useSignUpMutation
OBS:fiz quase examamente como na criacao do useSignInMutation, so que mais simples

19-Criando AlertBanner
OBS:Atualizei o theme adicionando cor para success e warning.
Primeiro eu criei o componente AlertBanner e seus arquivos, adicionei os icones check-circle, exclamation-circle e exclamation-triangle. Por fim eu adicionei o na pagina de login SignIn.tsx a linha <AlertBanner variant="error" message="Algo deu errado!"/> para teste

20-Tratando Erros
OBS:Primeiro, criei um hook useError para tratar erros na aplicacao.
Segundo, na pagina de login (SignIn.tsx) adicionei a linha:
const { error,handleError,clearError }=useError()

Terceiro, atualizei a onSubmit (requisicao de login) com um try catch para tratamento de erros no login:
    const onSubmit: SubmitHandler<SignInForm>= async(data)=>{//faz login
        try {
            clearError()
            await signIn(data)//faz requisicao de login
        } catch (error) {
            /*console.log(error) */
            handleError(error)

        }
    }

21-Rotas Autenticadas
OBS: Primeiro, Criei o componente RequireAuth que so armazena uma logica para que qualquer pagina apenas seja acessada se o usuario seja autenticado

Lembrando que dentro de RequireAuth.tsx eu criei uma linha:
if(!isAuthenticated){
        return <Navigate to="/" state={{ from: location }} replace />
    }
    Essa linha faz com que quando o accesstoken inspire e volte para a pagina de login, assim quando fizer o login novamente o usuario volte para a pagina antes do accesstoken espirar, melhorando a experiencia do usuario.

Segundo, criei uma rota fake para teste com nome Home na pasta Pages

Terceiro, adicionei a nova rota fake em app.tsx : 
<Route path='/home' element={<RequireAuth><Home/></RequireAuth>} />

Ainda eu adicionei ao arquivo api.ts o : api.interceptors.request.use
para que eu possa o accesstoken de forma automatica no localStorage
Na AuthContext.tsx eu coloquei export na interface Session para usar ela no api.ts para tipar com as Session


22-Adicionando Navegação no Login
OBS:Prmeiro no signIn.tsx eu criei o hook uselocation e usenavigate
Segundo, eu criei a variavel from (que armazenara o caminho da pagina home), 
Terceiro, dentro de TRY eu adicionei navigate(from), isso fara com que seja redirecionado para a pagina home quando o login for feito.

23-Adicionando Refresh Session
OBS:Naturalmente depois de implementar o api.interceptors.request.use no meu api, eu deveria implementar o tempo limite ao accesstoken para deslogar automaticamente o usuario para entao ele fazer o login novamente, ai entao depois do login seria gerado um novo par de accesstoken e refreshtoken, mas, para uma melhor experiencia do usuario farei a adicao do Refresh Session que checa se o accesstoken expirou e por meio de um refreshtoken que tem um tempo de expiracao maior, do que o accesstoken, a gente utiliza esse refreshtoken para gerar novos pares de accesstoken e refreshtoken para entao nao ter a necessidade do usuario ter que fazer o login novamente e so depois de expirar o refreshtoken que a conta seria deslogada.

24-Criando Cabeçalho
OBS:Essa eh a criacao do menu ou Cabeçalho do site que aparecera quando for logado. 
Primeiro, criei o componente Header que sera o menu. Dentro da pasta tem Header.styles.ts, Header.tsx e index.ts
Segundo, apos isso coloquei o Header na pagina logada que seria a pagina Home.tsx e para isso eu limpei ela e coloquei comente o Header.

25-Criando Layout da Área Logada
OBS: A necessidade de criar esse main layout eh para que eu nao deva sempre passar o menu/header/Cabeçalho para toda a pagina que eu criar, pode ser usado tambem com o footer/rodape do site.
 Primeiro eu criei a pasta Layouts e dentro dela criei o componente MainLayout com seus arquivos: index.ts, MainLayout.styles.ts e MainLayout.tsx.
 Segundo eu adicionei no pagina Home.tsx envovendo o conteudo do site com a tag MainLayout do componente MainLayout.tsx

 Vantagem disso eh que eu nao preciso estilizar o conteudo da pagina home na pagina home, como o conteudo vai ser enviado para o componente MainLayout eu estilizo o conteudo da pagina home no componente  MainLayout.

26-Criando Campo de Busca
OBS:Primeiro, Criei o componente de SearchBox e seus arquivos: index.ts, SearchBox.styles.ts e SearchBox.tsx
Segundo, coloquei o searchbox no componente Header.tsx

resultado foi a criacao da barra de pesquisa de livros colocando ele no componente Header

27-Buscando Livros
OBS:Criei um novo componente chamado Search com seus arquivos: index.ts, Search.tsx e Search.styles.ts.
segundo troquei o searchbox por serch dentro do componente Header.tsx

resultado foi um componente foi a criacao de um componente Search.tsx que tem o searchbox importado dentro dele e que faz a busca de livros assim que o usuario digita na pesquisa e aperta Enter, os livros aparecem como se fosse uma preview da pesquisa e abaixo dela tem um texto para ver todos os livros que foram achados na pesquisa abrindo outra pagina. Ainda somente uma lista de nomes do titulo do livro

28-Estilizando Resultado da Busca
OBS: criei o componente para exibir realmente os livros com titulo, nome do autor e a imagem de cada livro. 

Primeiro criei o componente SearchResultBook e com seus arquivos index.ts, SearchResultBook.tsx e SearchResultBook.styles.ts

Segundo: atualizei o serach.tsx, no retorno, dentro da tag SearchResultBookContainer coloquei a tag do nosso SearchResultBook passando os livros achados formatando o titulo, autor e imagem

resultado foi a preview da busca mais bonita e formatada com a imagem de cada livro

29-Criando Skeleton Loader
OBS:Vou criar um skeleton loader ou seja um esqueleto da pagina que pulsa enquanto a informacao nao esta disponivel na interface.
Primeiro criei o componente SkeletonLoader e seus arquivos: index.ts, SkeletonLoader.tsx e SkeletonLoader.styles.ts
Segundo, adicionei <SkeletonLoader width="200px" height="26px"/> no arquivo Search.tsx

resultado foi uma barra que com tamanho 200 por 26 com uma animacao 

30-Criando Search Loader
OBS:Primeiro criei a pasta SearchLoader dentro da pasta Search, junto com seus arquivos: index.ts, search.styles.ts e Search.tsx
Segundo, retirei o SkeletonLoader do arquivo Search.tsx, retirei o span escrito carregando... e no lugar desse span eu adicionei a tag <SearchLoader/> do componente que acabei de criar

31-Fechando Dropdown de Resultados
OBS:para fechar a preview da busca quando eh clicado fora da barra de pesquisa eu criei um hook e atualizei  o search.tsx
Primeiro eu criei um hook chamado useOutSideInteraction dentro da pasta hooks
Segundo eu criei dentro do arquivo Search.tsx: searchRef para guardar a ref da tag, nesse caso foi a div Container.
Terceiro, criei a funcao handleCloseResult para fechar a preview da busca
Quarto, chamei o hook useOutSideInteraction(searchRef, handleCloseResult) com ref e a funcao passando como parametros

32-Adicionando Ver Todos os Livros
OBS: Primeiro criei a pasta Books dentro de pages. Essa vai ser a pagina de livros achados na pesquisa.

Segundo, dentro de Search.tsx eu modifiquei a linha para <Link to={`/livros?q=${search}`}>Ver Todos</Link> Passando o termo que foi buscado para a barra de link do navegador

Terceiro, no arquivo App.tsx eu adicionei a pagina Books.tsx como uma das rotas da pagina, o nome dessa pagina sera '/livros'

Quarto, criei o hook useBooksQuery para fazer a pesquisa de livros, passando para ele o q (oque foi digitado e passado na barra de endereco) e passando o numero de livros que sera exibido assim que for clicado para ver mais livros no link(botao) 'Ver Todos'



33-Adicionando Cache a Query de Ver Todos os Livros
OBS:adicionei o cache no reactQuery adicionando "staleTime: Infinity" no arquivo useBooksQuery.ts

34-Adicionando Cache na Query do Campo de Busca
OBS:Adicionei o cache de busca, para a preview de busca de livros. 
Primeiro adicionei no arquivo useBooksQuery.ts a funcao useLazyBooksQuery para fazer o cache
Segundo no arquivo Search.tsx eu exclui o estados, result e loading
Terceiro, ainda em Search.tsx, dentro de handleSearch troquei api.get por fetch
Quarto, ainda em Search.tsx, dentro da tag SearchResultBookContainer em return, troquei result por data e loading por isLoading

35-Estilizando Ver Todos
OBS: Estilizei os livros achados na pesquisa.
Primeiro, criei o componente BookCard, com seus arquivos, index.ts, BookCard.tsx e BookCard.styles.ts.

segundo, na pasta src, eu criei a pasta models e dentro dela eu criei o arquivo Book.ts, aonde ficou uma interface que servira para varios componentes. Logo depois atualizei importanto esse model (interface Book) do arquivo Book.ts na interface BooksQueryResponse  no arquivo useBooksQuery.ts na pasta hooks.
O arquivo componente SearchResultBook.tsx dentro da pasta SearchResultBook tambem foi atualizado com o importe do Book.ts na sua interface SearchResultBookProps. (SOMENTE UMA ATUALIZACAO DE INTERFACES)

Terceiro, dentro do map no arquivo Books.tsx na pasta Books que esta na pasta pages, da seguinte forma: 
                        <li key={item.id}>
                            <BookCard key={item.id} book={item}/>
                        </li>

36-Adicionando Skeleton Loader em Ver Todos
OBS:Adicionei o skeleton na pagina com o resultado de todos os livros.
    Primeiro, criei o componente BookLoader(pasta) dentro da pasta Books pois sera um componente que somente sera utilizado pela pagina books, entao sera um componente criado exclusivamente para a pagina dos livros achados da busca. Criei o componente com seus arquivos BookLoader.tsx, index.ts e BookLoader.styles.ts. 

    Segundo, dentro do Books.tsx no seu retorno eu modifiquei fazendo um ternario da seguinte forma adicionando a tag do componente BookLoader que acabei de criar:

    {data && 
                    !isLoading? (
                        data.items.map((item)=> (
                            <li key={item.id}>
                                <BookCard key={item.id} book={item}/>
                            </li>
                        ))
                    ): (
                        <BookLoader/>
                    )}

o skeleton so aparece quando nao aparecer os livros achados


37-Criando Página de Detalhes do Livro
OBS:Primeiro, criei a pagina dos detalhes dos livros: Na pasta pages, a pasta BookDetail e seus arquivos, index.ts, BookDetail.tsx e BookDetail.styles.ts

Segundo, criei dois hooks, useBookDetails.ts para pegar os detalhes do livro na api. E useThumbnail para pegar as thumbnails dos livros 

Terceiro, criei a rota para a pagina  BookDetail

Quarto(extra), fiz algumas correcoes, como: mudei o componente Search de lugar, coloquei ele dentro da pasta components,

38-Adicionando React HTML Parser
OBS:como o texto do detalhe do livro vem com tags html, faz necessario usar o HTML parser

Primeiro, no terminal: yarn add react-html-parser

Segundo, no terminal: yarn add @types/react-html-parser -D

39-
OBS:

40-
OBS:

41-
OBS:

42-
OBS:

43-
OBS:

44-
OBS:

45-
OBS:

46-
OBS:

47-
OBS:

48-
OBS:

49-
OBS:

50-
OBS:
